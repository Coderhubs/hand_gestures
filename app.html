<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js Hand-Tracked Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; }
        .hint { font-size: 0.8em; opacity: 0.7; }
        video { display: none; } /* Hidden webcam feed */
    </style>
</head>
<body>

<div id="ui">
    <h2>Particle Controller</h2>
    <p>Gesture: <span id="gesture">Detecting...</span></p>
    <p class="hint">1 Finger: Fireworks | 2 Fingers: Heart | 3+ Fingers: Random</p>
</div>

<div id="container"></div>
<video id="input_video"></video>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    // --- 1. SET UP THREE.JS ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);
    camera.position.z = 50;

    // --- 2. PARTICLE SYSTEM ---
    const particleCount = 2000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
        
        colors[i * 3] = 1; colors[i * 3 + 1] = 0.5; colors[i * 3 + 2] = 0.8; 
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.5,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // --- 3. SHAPE TEMPLATES ---
    function setHeartShape() {
        for (let i = 0; i < particleCount; i++) {
            const t = (i / particleCount) * Math.PI * 2;
            targetPositions[i * 3] = 16 * Math.pow(Math.sin(t), 3) / 1.5;
            targetPositions[i * 3 + 1] = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) / 1.5;
            targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 5;
        }
    }

    function setFireworkShape() {
        for (let i = 0; i < particleCount; i++) {
            const r = 20 + Math.random() * 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            targetPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            targetPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            targetPositions[i * 3 + 2] = r * Math.cos(phi);
        }
    }

    // --- 4. HAND TRACKING LOGIC ---
    const videoElement = document.getElementById('input_video');
    const gestureText = document.getElementById('gesture');

    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults((results) => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            
            // Determine Finger Count (Simplified Gesture)
            const fingerTips = [8, 12, 16, 20];
            let count = 0;
            fingerTips.forEach(idx => {
                if (landmarks[idx].y < landmarks[idx - 2].y) count++;
            });

            // Trigger Shape Changes
            if (count === 1) {
                gestureText.innerText = "FIREWORK";
                setFireworkShape();
            } else if (count === 2) {
                gestureText.innerText = "HEART";
                setHeartShape();
            }

            // Expansion/Scale based on hand "depth" (distance between wrist and middle finger)
            const dx = landmarks[0].x - landmarks[12].x;
            const dy = landmarks[0].y - landmarks[12].y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            particleSystem.scale.setScalar(distance * 5);

            // Dynamically Change Color based on hand X position
            const hue = landmarks[8].x; // Using index finger X
            const colorAttr = geometry.attributes.color;
            for(let i=0; i<particleCount; i++) {
                const c = new THREE.Color().setHSL(hue, 0.8, 0.5);
                colorAttr.setXYZ(i, c.r, c.g, c.b);
            }
            colorAttr.needsUpdate = true;
        }
    });

    const cameraTrack = new Camera(videoElement, {
        onFrame: async () => { await hands.send({ image: videoElement }); },
        width: 640, height: 480
    });
    cameraTrack.start();

    // --- 5. ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);

        // Smoothly lerp particles to target positions
        const posAttr = geometry.attributes.position;
        for (let i = 0; i < particleCount * 3; i++) {
            posAttr.array[i] += (targetPositions[i] - posAttr.array[i]) * 0.1;
        }
        posAttr.needsUpdate = true;

        particleSystem.rotation.y += 0.01;
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>>